/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#pragma once
#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "TileablePerlinNoise_A.azsli"
#include "kr_utils.azsli"

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>



ShaderResourceGroup ObjectSrg : SRG_PerObject
{

    // DEFAULT STUFF
    uint m_objectId;

    //! Returns the matrix for transforming points from Object Space to World Space.
    float4x4 GetWorldMatrix()
    {
        return SceneSrg::GetObjectToWorldMatrix(m_objectId);
    }

    //! Returns the inverse-transpose of the world matrix.
    //! Commonly used to transform normals while supporting non-uniform scale.
    float3x3 GetWorldMatrixInverseTranspose()
    {
        return SceneSrg::GetObjectToWorldInverseTransposeMatrix(m_objectId);
    }

    float4x4 GetWorldMatrixPrev()
    {
        return SceneSrg::GetObjectToWorldMatrixPrev(m_objectId);
    }

    ReflectionProbeData m_reflectionProbeData;
    TextureCube m_reflectionProbeCubeMap;
    // DEFAULT STUFF

    //Buffer<float>  m_f_positionBuffer;
    //Texture2D<float4> m_t2_inputTexture; // A texture generated by a RenderJoy pipeline.

    uint m_u_gridWidth;
    uint m_u_gridLength;
    float m_f_cellSize;
    float m_f_placementNoiseScale;

    float m_f_totalHeight;
    float m_f_totalWidth;
    uint  m_u_maxSegments;



    float SegmentHeight(){
        return m_f_totalHeight / m_u_maxSegments;
    }

    uint m_u_vertexCountPerMesh(){
        return 6 * m_u_maxSegments-3;
    }

    float m_f_loopLength; 
    float2 m_f2_leafWidthCurvePoint1;
    float2 m_f2_leafWidthCurvePoint2;

    float2 m_f2_leafDefaultShapePoint2;
    float2 m_f2_leafDefaultShapePoint3;

    float2 m_f2_leafFullWindShapePoint2;
    float2 m_f2_leafFullWindShapePoint3;


    // float3 m_f3_baseColor = float3(1,1,1);
    // float m_f_metallic = 0.0f;
    // float m_f_roughness = 0.9f;
    // float m_f_alpha = 1.0f;
    // float m_f_diffuseAmbientOcclusion = 0.3f;
    // float m_f_specularF0Factor = 0.1f;
    // float m_f_specularOcclusion = 0.5f;
    float3 m_f3_baseColor;
    float m_f_metallic;
    float m_f_roughness;
    float m_f_alpha;
    float m_f_diffuseAmbientOcclusion;
    float m_f_specularF0Factor;
    float m_f_specularOcclusion;

    float3 GetVertexModelPositionBezier(uint vertexId,float scale)
    {
        // If you use your right hand
        // these trinagles are facing in Y+ direction, 
        // 3 2---0  
        // | \\  |
        // |  \\ |
        // 5---4 1
        uint vertexIndex = vertexId % 6;
        uint segmentIndex = vertexId / 6;
        bool isHead = vertexId >= m_u_vertexCountPerMesh()-3;

        const float3 expansion[6] =
        {
            float3( m_f_totalWidth, 0,  SegmentHeight()),
            float3( m_f_totalWidth, 0, 0),
            float3(-m_f_totalWidth, 0,  SegmentHeight()),
            float3(-m_f_totalWidth, 0,  SegmentHeight()),
            float3( m_f_totalWidth, 0, 0),
            float3(-m_f_totalWidth, 0, 0),
        };
        const float3 head[3] =
        {
            float3(-m_f_totalWidth, 0,  0),
            float3( 0, 0,  SegmentHeight()*1),
            float3( m_f_totalWidth, 0,  0),
        };
        float3 vertexModelPosition;
        if (isHead)
        {
            vertexModelPosition = head[vertexIndex];
        }else{
            vertexModelPosition = expansion[vertexIndex];
        }
        vertexModelPosition.z += segmentIndex * SegmentHeight();
        const float2 points[3] = {
            m_f2_leafWidthCurvePoint1,
            m_f2_leafWidthCurvePoint2,
            float2(1,0)
        };

        vertexModelPosition.x *= scale;
        vertexModelPosition.z *= scale;

        vertexModelPosition.x *= getPointAt2d(vertexModelPosition.z/m_f_totalHeight,points[0],points[1],points[2]).y;
    // vertexModelPosition.y = yVal;
        return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
    }


    float3 RotateAroundZ(float3 position, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
        float3 p = position;
        float3 rotated;
        rotated.x = p.x * c - p.y * s;
        rotated.y = p.x * s + p.y * c;
        rotated.z = p.z;
        return float3(rotated);
    }

    void RotateAroundZ2(inout float3 position,inout float3 normal,float angle){
        position = RotateAroundZ(position,angle);
        normal = RotateAroundZ(normal,angle);
    }

      
    float3 GetBillboardPosition(uint billboardIndex)
    {
        //return float3(1,1,1);
        uint x = billboardIndex % m_u_gridWidth;
        uint y = billboardIndex / m_u_gridWidth;
        // Calculate base position based on grid index and cell size
        float3 position;
        position.x = (x + 0.5) * m_f_cellSize - (m_u_gridWidth * m_f_cellSize) / 2.0f; 
        position.z = 0;
        position.y = (y + 0.5) * m_f_cellSize - (m_u_gridLength * m_f_cellSize) / 2.0f; 

        // add some random offset to the position
        float2 noise =  randomNormalPair(billboardIndex*134);
        position.xy += noise * m_f_cellSize * m_f_placementNoiseScale;
        return position; 
    }

    


    // float PerlinNoiseFbm(float3 input, float frequency, int octaves, float persistence) {
    void PushByPerlinNoise(inout float3 position,inout float3 normal, uint billboardIndex, float windStrength,float scale){

        float2 points[3] = {
            float2(0,0),
            m_f2_leafDefaultShapePoint2,
            m_f2_leafDefaultShapePoint3
        };

        float2 pointsWind[3] = {
            float2(0,0),
            m_f2_leafFullWindShapePoint2,
            m_f2_leafFullWindShapePoint3
        };

        const float scaled_z = position.z / (m_f_totalHeight * scale);
        float2 pointsLerp[3] = {
            float2(0,0),
            float2(0,0),
            float2(0,0)
        };
        for (int i = 1; i < 3; i++)
        {
            pointsLerp[i] = lerp(points[i],pointsWind[i],windStrength) * scale;
        }

        const float2 pushed_point = getPointAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
        position.yz = pushed_point.xy;
        normal.yz = getNormalAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
    }
}
