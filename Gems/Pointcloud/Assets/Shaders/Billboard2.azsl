/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
#include <Atom/Features/ParallaxMapping.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "TileablePerlinNoise_A.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassOutput.azsli>
#include <Atom/Features/PBR/AlphaUtils.azsli>
#include <Atom/Features/PBR/LightingOptions.azsli>

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>

#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <Atom/Features/Pipeline/Forward/ForwardPassSrg.azsli>

#include <Atom/Features/PBR/Lighting/StandardLighting.azsli>
#include <Atom/Features/PBR/Lights/IblForward.azsli>
#include <Atom/Features/PBR/Decals.azsli>
#include <Atom/Features/ColorManagement/TransformColor.azsli>

static float TotalHeight = 2.0;
static float TotalWidth = 0.1;
static uint MaxSegments = 4;
static float SegmentHeight = TotalHeight / MaxSegments;
static float LoopLength = 30.0;
static uint TotalVertices = MaxSegments *6 -3;


float GetScaledTime(float time)
{
    return time / LoopLength;
}

float3 GetVertexModelPosition(uint vertexId)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    uint vertexIndex = vertexId % 6;
    uint segmentIndex = vertexId / 6;
    bool isHead = vertexId >= TotalVertices-3;

    const float3 expansion[6] =
    {
        float3( TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0, 0),
    };
    const float3 head[3] =
    {
        float3(-TotalWidth, 0,  0),
        float3( 0.5*TotalWidth, 0,  SegmentHeight*1),
        float3( TotalWidth, 0,  0),
    };
    float3 vertexModelPosition;
    if (isHead)
    {
        vertexModelPosition = head[vertexIndex];
    }else{
        vertexModelPosition = expansion[vertexIndex];
    }
    vertexModelPosition.z += segmentIndex * SegmentHeight;
   // vertexModelPosition.y = yVal;
    return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
}

float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1),      
    };
    uint vertexIndex = vertexId % 6;
    return texcoord[vertexIndex];
}

// ShaderResourceGroup PerObjectSrg : SRG_PerDraw
// {
//     float m_time;
// }

// ShaderResourceGroup PerDrawSrg : SRG_PerObject
ShaderResourceGroup PerDrawSrg : SRG_PerDraw
{ 

    Buffer<float>  m_positionBuffer;
    Buffer<float> m_objectToWorldMatrixInverseTranspose;
    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.
    float m_time;
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Mirror;
        AddressV = Mirror;
        AddressW = Mirror;
    };

    float3 RotateAroundZ(float3 position, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
        float3 p = position;
        float3 rotated;
        rotated.x = p.x * c - p.y * s;
        rotated.y = p.x * s + p.y * c;
        rotated.z = p.z;
        return float3(rotated);
    }

    void RotateAroundZ2(inout float3 position,inout float3 normal,float angle){
        position = RotateAroundZ(position,angle);
        normal = RotateAroundZ(normal,angle);
    }

    float getPointAt(float t, float p1, float pc, float p2) {
        return (1 - t) * (1 - t) * p1 + 2 * (1 - t) * t * pc + t * t * p2;
    }

    float getDerivativeAt(float t, float p1, float pc, float p2) {
        float d1 = 2 * (pc - p1);
        float d2 = 2 * (p2 - pc);

        return (1 - t) * d1 + t * d2;
    }

    float getNormalAt(float t, float p1, float pc, float p2) {
        float d = getDerivativeAt(t, p1, pc, p2);
        float q = sqrt(d * d);

        return -d / q;
    }

    float CubicBezier(float a, float b, float c, float d, float t)
    {
        return lerp(lerp(lerp(a, b, t), lerp(b, c, t), t), lerp(lerp(b, c, t), lerp(c, d, t), t), t);
    }

    float CubicBezierDerivative(float a, float b, float c, float d, float t)
    {
        return lerp(lerp(lerp(b - a, c - b, t), lerp(c - b, d - c, t), t), lerp(lerp(c - b, d - c, t), lerp(d - c, d - c, t), t), t);
    }

    float3 GetBillboardPosition(uint billboardIndex)
    {
        return float3(
            m_positionBuffer[3 + 16 * billboardIndex], // x component of translation
            m_positionBuffer[7 + 16 * billboardIndex], // y component of translation
            m_positionBuffer[11 + 16 * billboardIndex] // z component of translation
        );
    }

    // float PerlinNoiseFbm(float3 input, float frequency, int octaves, float persistence) {
    void PushByPerlinNoise(inout float3 position,inout float3 normal, uint billboardIndex){
        float3 center_position = GetBillboardPosition(billboardIndex);
        float3 wind_direction = normalize(float3(2,1,0.1));
        // 

        float3 noise_position = float3( center_position.x,center_position.y,0);
        noise_position += wind_direction * PerDrawSrg::m_time*LoopLength*10;
        float noise = PerlinNoiseFbm(noise_position, 1/LoopLength, 2, 1);
        const float scaled_z = position.z / TotalHeight;
        const float y_push = PerDrawSrg::getPointAt(scaled_z*noise,0,.1,10.0);
        // Modify the y value of the input position based on the y value of P
        position.y = y_push; //* noise*5;
        
        // compute normal
        normal.x = getDerivativeAt(scaled_z*noise,0,.1,10.0);

        //move normal and position based on noise 
        // position.y *= noise*3;
        

    }
}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
    
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
    float3 m_worldPosition : UV0;
    float4 m_color : COLOR;
    float3 m_normal : NORMAL;

};

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(TotalVertices);
    const uint billboardIndex = uint(IN.m_vertexID) / uint(TotalVertices);
    float3 translation = PerDrawSrg::GetBillboardPosition(billboardIndex);
    float3 vertexModelPosition = GetVertexModelPosition(vertexIndex);
    float3 normal = float3(0,0,1);
    PerDrawSrg::PushByPerlinNoise(vertexModelPosition,normal,billboardIndex);

    
    // // Rotate towards camera
    // float3 cameraPos = ViewSrg::m_worldPosition;

    // float3 right = cross(float3(0, 0, -1), forward); // Cross product of up and forward vectors
    // float3 up = float3(0, 0, 1);

    
    // if (!isInfront)
    // {
    //     right = -right;
    // }
    // right *= 0.2;
    
    // noise for rotation
    float3 noise_position = float3( translation.x,translation.y+0.5,PerDrawSrg::m_time*LoopLength*3);
    float rotation_noise = PerlinNoiseFbm(noise_position, 1/LoopLength, 2, 1);
    PerDrawSrg::RotateAroundZ2(vertexModelPosition, normal,rotation_noise);
    

    float4 vertexWorldPosition = float4(vertexModelPosition + translation, 1.0);
    

    // bool frontVisible = dot(normal,ViewSrg::m_worldPosition - vertexWorldPosition.xyz) > 0;
    // if (!frontVisible)
    // {
    //     normal = -normal;
    // }


    // // 1. Compute angle between the camera and the billboard
    // // 2. Rotate the billboard around the center of the blade such that it faces the camera
    // // 3. Compute the world position of the vertex after rotation

    // // 1 

    // // 2
    // float3 center = float3(translation.x,translation.y,0);
    // float3 rotatedVertexPosition = PerDrawSrg::RotateAroundZ(vertexWorldPosition,center,0);

    // // 3
    // const row_major float4x4 tm = {
    //     right.x, forward.x, up.x, rotatedVertexPosition.x,
    //     right.y, forward.y, up.y, rotatedVertexPosition.y,
    //     right.z, forward.z, up.z, rotatedVertexPosition.z,
    //             0,           0,    0,            1.0,
    // };
    // vertexWorldPosition = mul(tm, float4(vertexModelPosition, 1));

    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    OUT.m_normal = normalize(normal);//float3(1,0,0);
    OUT.m_worldPosition = vertexWorldPosition.xyz;

    // color based on distance from 0.0
    float distance = length(vertexModelPosition.xz - float2(0.0, TotalHeight*0.8 ))/TotalHeight;
    // clamp to 0.0 to 0.2
    distance = max(0.0, min(0.4, distance));
    // green color with saturation based on distance
    float3 green = float3(0, 1, 0);
    // change to hsv
    float3 hsv = RgbToHsv(green);
    // change saturation
    hsv.y -= distance;
    // change back to rgb
    float4 color = float4(HsvToRgb(hsv),1);
    OUT.m_color = color;
    //OUT.m_color = float4(0.3,0.7,0,1);
    //OUT.m_color = float4(distance, distance, distance, 1);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);

    
    return OUT;
};


ForwardPassOutput MainPS(VSOutput IN)
{

        
    float3 baseColor = IN.m_color.rgb;
    float3 surfaceNormal = IN.m_normal;
    const float3 surfaceNormalWorld = IN.m_normal;
    
    // ------- Surface -------

    Surface surface;
    
    // Position, Normal, Roughness
    surface.position = IN.m_worldPosition.xyz;
    surface.normal = normalize(surfaceNormalWorld);
    surface.vertexNormal = surfaceNormal;
    surface.roughnessLinear = 0.5f;
    surface.CalculateRoughnessA();

    // Albedo, SpecularF0
    const float metallic = 0.3f;
    const float specularF0Factor = 0.5f;
    surface.SetAlbedoAndSpecularF0(baseColor, specularF0Factor, metallic);

    // Clear Coat
    surface.clearCoat.InitializeToZero();

    // ------- LightingData -------

    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(IN.m_position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    // (real3 positionWS, real3 normal, real roughnessLinear)
    lightingData.Init(ViewSrg::m_worldPosition.xyz, surface.normal, surface.roughnessLinear);

    // Shadow
    lightingData.diffuseAmbientOcclusion = 0.1f;

    // Diffuse and Specular response
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0f - lightingData.specularResponse;

    const float alpha = 1.0f;

    // ------- Lighting Calculation -------

    // Apply Decals
    ApplyDecals(lightingData.tileIterator, surface);

    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData, IN.m_position);

    // Apply Image Based Lighting (IBL)
    ApplyIblForward(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting();

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);

    // ------- Output -------
    ForwardPassOutput OUT;
    lightingOutput.m_diffuseColor.a = 1.0f;
    OUT.m_diffuseColor = lightingOutput.m_diffuseColor;
    OUT.m_diffuseColor.w = -1; // Subsurface scattering is disabled
    OUT.m_specularColor =  lightingOutput.m_specularColor;
    //OUT.m_specularColor =  float4(lightingData.diffuseLighting,1);
    //bool isLight = o_enableAreaLights;
    // if (isLight)
    // {
    //     OUT.m_specularColor = float4(0,1,0,1);
    // }else{
    //     OUT.m_specularColor =  float4(1,0,0,1);
    // }

   
    OUT.m_specularF0 = lightingOutput.m_specularF0;
    OUT.m_albedo = lightingOutput.m_albedo;
    OUT.m_normal = lightingOutput.m_normal;
    return OUT;
}; 
