/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>

float3 GetVertexModelPosition(uint vertexId, float heightToWidthRatio)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    const float3 expansion[6] =
    {
        float3( 1, 0,  heightToWidthRatio),
        float3( 1, 0, -heightToWidthRatio),
        float3(-1, 0,  heightToWidthRatio),
        float3(-1, 0,  heightToWidthRatio),
        float3( 1, 0, -heightToWidthRatio),
        float3(-1, 0, -heightToWidthRatio),
    };
    float3 vertexModelPosition = expansion[vertexId];
   // vertexModelPosition.y = yVal;
    return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
}

float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1),      
    };

    return texcoord[vertexId];
}

ShaderResourceGroup PerObjectSrg : SRG_PerDraw
{

}

ShaderResourceGroup PerDrawSrg : SRG_PerObject
{

    Buffer<float>  m_positionBuffer;
    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.

    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Mirror;
        AddressV = Mirror;
        AddressW = Mirror;
    };

    float4 GetWorldPositionBuffer(float3 modelPosition,const uint bilboardIndex)
    {
        const row_major float4x4 m_modelToWorld2 = float4x4(
            m_positionBuffer[0+16*bilboardIndex], m_positionBuffer[1+16*bilboardIndex], m_positionBuffer[2+16*bilboardIndex], m_positionBuffer[3+16*bilboardIndex],
            m_positionBuffer[4+16*bilboardIndex], m_positionBuffer[5+16*bilboardIndex], m_positionBuffer[6+16*bilboardIndex], m_positionBuffer[7+16*bilboardIndex],
            m_positionBuffer[8+16*bilboardIndex], m_positionBuffer[9+16*bilboardIndex], m_positionBuffer[10+16*bilboardIndex], m_positionBuffer[11+16*bilboardIndex],
            m_positionBuffer[12+16*bilboardIndex], m_positionBuffer[13+16*bilboardIndex], m_positionBuffer[14+16*bilboardIndex], m_positionBuffer[15+16*bilboardIndex]
        );

        const float3 myWorldPos =  m_modelToWorld2._m03_m13_m23;

        // Need to preserve the scale.
        float3 r = m_modelToWorld2._m00_m10_m20;
        float3 f = m_modelToWorld2._m01_m11_m21;
        float3 u = m_modelToWorld2._m02_m12_m22;
        float3 scale = float3(length(r), length(f), length(u));


        const float3 cameraPos = ViewSrg::m_worldPosition;
        float3 cameraPos2 = float3(cameraPos.x,cameraPos.y,myWorldPos.z);
        float3 myForward = normalize(cameraPos2 - myWorldPos);
        float3 myRight = cross(float3(0, 0, -1), myForward); // Cross product of up and forward vectors
        float3 myUp = float3(0, 0, 1);

        myRight *= scale.x;
        myUp *= scale.y;
        const row_major float4x4 tm = {
            myRight.x, myForward.x, myUp.x, myWorldPos.x,
            myRight.y, myForward.y, myUp.y, myWorldPos.y,
            myRight.z, myForward.z, myUp.z, myWorldPos.z,
                    0,           0,      0,            1.0,
        };
        return mul(tm, float4(modelPosition, 1));

    }

    float4 GetBillboardClipCoordinates(const uint vertexIndex,const uint bilboardIndex)
    {
        // uint2 texDims;
        // m_inputTexture.GetDimensions(texDims.x, texDims.y);
        const float heightToWidthRatio = 1.0; // float(texDims.y) / float(texDims.x);
        const float3 vertexModelPosition = GetVertexModelPosition(vertexIndex, heightToWidthRatio);
        const float4 vertexWorldPosition = PerDrawSrg::GetWorldPositionBuffer(vertexModelPosition,bilboardIndex);
        return mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    }

}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
    
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
};

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(6);
    const uint bilboardIndex = uint(IN.m_vertexID) / uint(6);
    OUT.m_position = PerDrawSrg::GetBillboardClipCoordinates(vertexIndex,bilboardIndex);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);
    return OUT;
};

struct PSOutput
{
    float4 m_color : SV_Target0;
};

PSOutput MainPS(VSOutput IN)
{
    PSOutput OUT;
    // OUT.m_color = float4(1, 0, 0, 1);
    // return OUT;
    const float2 texCoord = IN.m_texCoord.xy;

    float4 color = PerDrawSrg::m_inputTexture.Sample(PerDrawSrg::LinearSampler, texCoord).rgba;

   // color.a = 0.50;
 //  color.r = 1.00;
    if (color.a < 0.5) // Change this condition as per your requirement
    {
        discard;
    }

    OUT.m_color = color;
    return OUT;

}; 
