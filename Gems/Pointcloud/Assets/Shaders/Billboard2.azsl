/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>

static float TotalHeight = 2.0;
static float TotalWidth = 0.1;
static uint MaxSegments = 4;
static float SegmentHeight = TotalHeight / MaxSegments;
static float LoopLength = 5.0;
static uint TotalVertices = MaxSegments *6 -3;

float GetScaledTime(float time)
{
    return time / LoopLength;
}

float3 GetVertexModelPosition(uint vertexId, float heightToWidthRatio)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    uint vertexIndex = vertexId % 6;
    uint segmentIndex = vertexId / 6;
    bool isHead = vertexId >= TotalVertices-3;

    const float3 expansion[6] =
    {
        float3( TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0, 0),
    };
    const float3 head[3] =
    {
        float3(-TotalWidth, 0,  0),
        float3( 0.5*TotalWidth, 0,  SegmentHeight*1),
        float3( TotalWidth, 0,  0),
    };
    float3 vertexModelPosition;
    if (isHead)
    {
        vertexModelPosition = head[vertexIndex];
    }else{
        vertexModelPosition = expansion[vertexIndex];
    }
    vertexModelPosition.z += segmentIndex * SegmentHeight;
   // vertexModelPosition.y = yVal;
    return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
}

float3 MoveUsingTime(float3 position, float time)
{
    // based height (z) move the vertex 
    // first compute z**2 to make 
    float scaled_z = position.z /TotalHeight;
    float z2 = scaled_z*scaled_z;
    float timeSclaed =(time-0.5) *z2;

    return position + float3(timeSclaed, 0, 0)*3;
}

float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1),      
    };
    uint vertexIndex = vertexId % 6;
    return texcoord[vertexIndex];
}

// ShaderResourceGroup PerObjectSrg : SRG_PerDraw
// {
//     float m_time;
// }

// ShaderResourceGroup PerDrawSrg : SRG_PerObject
ShaderResourceGroup PerDrawSrg : SRG_PerDraw
{ 

    Buffer<float>  m_positionBuffer;
    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.
    float m_time;
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Mirror;
        AddressV = Mirror;
        AddressW = Mirror;
    };

    float4 GetWorldPositionBuffer(float3 modelPosition,const uint bilboardIndex)
    {
        const row_major float4x4 m_modelToWorld2 = float4x4(
            m_positionBuffer[0+16*bilboardIndex], m_positionBuffer[1+16*bilboardIndex], m_positionBuffer[2+16*bilboardIndex], m_positionBuffer[3+16*bilboardIndex],
            m_positionBuffer[4+16*bilboardIndex], m_positionBuffer[5+16*bilboardIndex], m_positionBuffer[6+16*bilboardIndex], m_positionBuffer[7+16*bilboardIndex],
            m_positionBuffer[8+16*bilboardIndex], m_positionBuffer[9+16*bilboardIndex], m_positionBuffer[10+16*bilboardIndex], m_positionBuffer[11+16*bilboardIndex],
            m_positionBuffer[12+16*bilboardIndex], m_positionBuffer[13+16*bilboardIndex], m_positionBuffer[14+16*bilboardIndex], m_positionBuffer[15+16*bilboardIndex]
        );

        const float3 myWorldPos =  m_modelToWorld2._m03_m13_m23;

        // Need to preserve the scale.
        float3 r = m_modelToWorld2._m00_m10_m20;
        float3 f = m_modelToWorld2._m01_m11_m21;
        float3 u = m_modelToWorld2._m02_m12_m22;
        float3 scale = float3(length(r), length(f), length(u));


        const float3 cameraPos = ViewSrg::m_worldPosition;
        float3 cameraPos2 = float3(cameraPos.x,cameraPos.y,myWorldPos.z);
        float3 myForward = normalize(cameraPos2 - myWorldPos);
        float3 myRight = cross(float3(0, 0, -1), myForward); // Cross product of up and forward vectors
        float3 myUp = float3(0, 0, 1);

        myRight *= scale.x;
        myUp *= scale.y;
        const row_major float4x4 tm = {
            myRight.x, myForward.x, myUp.x, myWorldPos.x,
            myRight.y, myForward.y, myUp.y, myWorldPos.y,
            myRight.z, myForward.z, myUp.z, myWorldPos.z,
                    0,           0,      0,            1.0,
        };
        return mul(tm, float4(modelPosition, 1));

    }

    float4 GetBillboardClipCoordinates(const uint vertexIndex,const uint bilboardIndex)
    {
        // uint2 texDims;
        // m_inputTexture.GetDimensions(texDims.x, texDims.y);
        const float heightToWidthRatio = 1.0; // float(texDims.y) / float(texDims.x);
        const float3 vertexModelPosition = GetVertexModelPosition(vertexIndex, heightToWidthRatio);
        const float3 movedVertexPosition = MoveUsingTime(vertexModelPosition,PerDrawSrg::m_time);
        
        //return mul(ViewSrg::m_viewProjectionMatrix, float4(movedVertexPosition,1));
        const float4 vertexWorldPosition = PerDrawSrg::GetWorldPositionBuffer(movedVertexPosition,bilboardIndex);
        return mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    }

}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
    
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
    float4 m_color : COLOR;
};

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(TotalVertices);
    const uint bilboardIndex = uint(IN.m_vertexID) / uint(TotalVertices);

    const float heightToWidthRatio = 1.0; // float(texDims.y) / float(texDims.x);
    const float3 vertexModelPosition = GetVertexModelPosition(vertexIndex, heightToWidthRatio);
    const float3 movedVertexPosition = MoveUsingTime(vertexModelPosition,PerDrawSrg::m_time);
    
    //return mul(ViewSrg::m_viewProjectionMatrix, float4(movedVertexPosition,1));
    const float4 vertexWorldPosition = PerDrawSrg::GetWorldPositionBuffer(movedVertexPosition,bilboardIndex);
    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);

    //OUT.m_position = PerDrawSrg::GetBillboardClipCoordinates(vertexIndex,bilboardIndex);
    // color based on distance from 0.0
    float distance = length(vertexModelPosition.xz - float2(0.0, TotalHeight*0.8 ))/TotalHeight;
    // clamp to 0.0 to 0.2
    distance = max(0.0, min(0.2, distance));
    // green color with saturation based on distance
    float3 green = float3(0, 1, 0);
    // change to hsv
    float3 hsv = RgbToHsv(green);
    // change saturation
    hsv.y -= distance;
    // change back to rgb
    float4 color = float4(HsvToRgb(hsv),1);
    OUT.m_color = color;
    //OUT.m_color = float4(distance, distance, distance, 1);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);
    return OUT;
};

struct PSOutput
{
    float4 m_color : SV_Target0;
};

PSOutput MainPS(VSOutput IN)
{
    PSOutput OUT;
    // OUT.m_color = float4(1, 0, 0, 1);
    // return OUT;
    const float2 texCoord = IN.m_texCoord.xy;

    float4 color = PerDrawSrg::m_inputTexture.Sample(PerDrawSrg::LinearSampler, texCoord).rgba;
    color = float4(0, 1, 0, 1);

    // color is based on distance from 0.0
    float distance =  length(texCoord - float2(0.5, 0.5));
    color = IN.m_color;

   // color.a = 0.50;
 //  color.r = 1.00;
    if (color.a < 0.5) // Change this condition as per your requirement
    {
        discard;
    }
    
    OUT.m_color = color;
    //OUT.m_color = float4(1, 1, 1, 1);
    return OUT;

}; 
