/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
#include <Atom/Features/ParallaxMapping.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "TileablePerlinNoise_A.azsli"
#include "LightHelper.azsli"
static float TotalHeight = 2.0;
static float TotalWidth = 0.1;
static uint MaxSegments = 4;
static float SegmentHeight = TotalHeight / MaxSegments;
static float LoopLength = 30.0;
static uint TotalVertices = MaxSegments *6 -3;


float GetScaledTime(float time)
{
    return time / LoopLength;
}

float3 GetVertexModelPosition(uint vertexId, float heightToWidthRatio)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    uint vertexIndex = vertexId % 6;
    uint segmentIndex = vertexId / 6;
    bool isHead = vertexId >= TotalVertices-3;

    const float3 expansion[6] =
    {
        float3( TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0, 0),
    };
    const float3 head[3] =
    {
        float3(-TotalWidth, 0,  0),
        float3( 0.5*TotalWidth, 0,  SegmentHeight*1),
        float3( TotalWidth, 0,  0),
    };
    float3 vertexModelPosition;
    if (isHead)
    {
        vertexModelPosition = head[vertexIndex];
    }else{
        vertexModelPosition = expansion[vertexIndex];
    }
    vertexModelPosition.z += segmentIndex * SegmentHeight;
   // vertexModelPosition.y = yVal;
    return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
}

float3 MoveUsingTime(float3 position, float time)
{
    // based height (z) move the vertex 
    // first compute z**2 to make 
    float scaled_z = position.z /TotalHeight;
    float z2 = scaled_z*scaled_z;
    float timeSclaed =(time-0.5) *z2;

    return position + float3(timeSclaed, 0, 0)*3;
}

float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1),      
    };
    uint vertexIndex = vertexId % 6;
    return texcoord[vertexIndex];
}

// ShaderResourceGroup PerObjectSrg : SRG_PerDraw
// {
//     float m_time;
// }

// ShaderResourceGroup PerDrawSrg : SRG_PerObject
ShaderResourceGroup PerDrawSrg : SRG_PerDraw
{ 

    Buffer<float>  m_positionBuffer;
    Buffer<float> m_objectToWorldMatrixInverseTranspose;
    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.
    float m_time;
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Mirror;
        AddressV = Mirror;
        AddressW = Mirror;
    };

    float4 GetWorldPositionBuffer(float3 modelPosition,const uint billboardIndex)
    {
        const row_major float4x4 m_modelToWorld2 = float4x4(
            m_positionBuffer[0+16*billboardIndex], m_positionBuffer[1+16*billboardIndex], m_positionBuffer[2+16*billboardIndex], m_positionBuffer[3+16*billboardIndex],
            m_positionBuffer[4+16*billboardIndex], m_positionBuffer[5+16*billboardIndex], m_positionBuffer[6+16*billboardIndex], m_positionBuffer[7+16*billboardIndex],
            m_positionBuffer[8+16*billboardIndex], m_positionBuffer[9+16*billboardIndex], m_positionBuffer[10+16*billboardIndex], m_positionBuffer[11+16*billboardIndex],
            m_positionBuffer[12+16*billboardIndex], m_positionBuffer[13+16*billboardIndex], m_positionBuffer[14+16*billboardIndex], m_positionBuffer[15+16*billboardIndex]
        );

        const float3 myWorldPos =  m_modelToWorld2._m03_m13_m23;

        // Need to preserve the scale.
        float3 r = m_modelToWorld2._m00_m10_m20;
        float3 f = m_modelToWorld2._m01_m11_m21;
        float3 u = m_modelToWorld2._m02_m12_m22;
        float3 scale = float3(length(r), length(f), length(u));


        const float3 cameraPos = ViewSrg::m_worldPosition;
        float3 cameraPos2 = float3(cameraPos.x,cameraPos.y,myWorldPos.z);
        float3 myForward = normalize(cameraPos2 - myWorldPos);
        float3 myRight = cross(float3(0, 0, -1), myForward); // Cross product of up and forward vectors
        float3 myUp = float3(0, 0, 1);

        myRight *= scale.x;
        myUp *= scale.y;
        const row_major float4x4 tm = {
            myRight.x, myForward.x, myUp.x, myWorldPos.x,
            myRight.y, myForward.y, myUp.y, myWorldPos.y,
            myRight.z, myForward.z, myUp.z, myWorldPos.z,
                    0,           0,      0,            1.0,
        };
        return mul(tm, float4(modelPosition, 1));

    }

    float3 RotateAroundZ(float3 position, float3 center, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
        float3 p = position - center;
        float3 rotated;
        rotated.x = p.x * c - p.y * s;
        rotated.y = p.x * s + p.y * c;
        rotated.z = p.z;
        return float3(rotated + center);
    }

    float3 RotateAroundBladeCenter(float3 position,float angle,uint billboardIndex){
        float3 translation = float3(
            m_positionBuffer[3 + 16 * billboardIndex], // x component of translation
            m_positionBuffer[7 + 16 * billboardIndex], // y component of translation
            m_positionBuffer[11 + 16 * billboardIndex] // z component of translation
        );
        float3 center = float3(translation.x,translation.y,0);
        return RotateAroundZ(position,center,angle);
    }
        

    float4 GetWorldPositionBufferNoRotation(float3 modelPosition, const uint billboardIndex)
    {
        // Extract the translation part directly from the position buffer for the specified billboard index
        float3 translation = float3(
            m_positionBuffer[3 + 16 * billboardIndex], // x component of translation
            m_positionBuffer[7 + 16 * billboardIndex], // y component of translation
            m_positionBuffer[11 + 16 * billboardIndex] // z component of translation
        );

        // Apply the translation to the model position without modifying its orientation
        float4 worldPosition = float4(modelPosition + translation, 1.0);

        return worldPosition;
    }

    float CubicBezier(float a, float b, float c, float d, float t)
    {
        return lerp(lerp(lerp(a, b, t), lerp(b, c, t), t), lerp(lerp(b, c, t), lerp(c, d, t), t), t);
    }

    float3 PushByCurve(float3 position){
        // Define two constant control points for the Bezier curve
        const float scaled_z = position.z / TotalHeight;
        const float y_push = PerDrawSrg::CubicBezier(.2,.3,.5,.86,scaled_z);
        // Modify the y value of the input position based on the y value of P
        position.y -= y_push;

        // Return the modified position
        return position;
    }
    // float PerlinNoiseFbm(float3 input, float frequency, int octaves, float persistence) {
    //     float total = 0;
    //     float amplitude = 1;
    //     for(int i = 0; i < octaves; i++) {
    //         total += TileablePerlin3D(input * frequency, frequency) * amplitude;
    //         frequency *= 2;
    //         amplitude *= persistence;
    //     }
        
    //     return total;
    // }

    float3 PushByPerlinNoise(float3 position,float3 center_position){
        float3 noise_position = float3( center_position.x,center_position.y,m_time*LoopLength*3);
        float noise = PerlinNoiseFbm(noise_position, 1/LoopLength, 2, 1);
        const float scaled_z = position.z / TotalHeight;
        const float y_push = PerDrawSrg::CubicBezier(.2,.3,.5,.86,scaled_z);
        // Modify the y value of the input position based on the y value of P
        position.y -= y_push * noise*10;
        return position;
    }

    float4 GetBillboardClipCoordinates(const uint vertexIndex,const uint billboardIndex)
    {
        // uint2 texDims;
        // m_inputTexture.GetDimensions(texDims.x, texDims.y);
        const float heightToWidthRatio = 1.0; // float(texDims.y) / float(texDims.x);
        const float3 vertexModelPosition = GetVertexModelPosition(vertexIndex, heightToWidthRatio);
        const float3 movedVertexPosition = MoveUsingTime(vertexModelPosition,0.5);
        
        //return mul(ViewSrg::m_viewProjectionMatrix, float4(movedVertexPosition,1));
        const float4 vertexWorldPosition = PerDrawSrg::GetWorldPositionBuffer(movedVertexPosition,billboardIndex);
        return mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    }

}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
    
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
    float4 m_color : COLOR;
    float3 m_normal : NORMAL;

};

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(TotalVertices);
    const uint billboardIndex = uint(IN.m_vertexID) / uint(TotalVertices);
    float3 translation = float3(
        PerDrawSrg::m_positionBuffer[3 + 16 * billboardIndex], // x component of translation
        PerDrawSrg::m_positionBuffer[7 + 16 * billboardIndex], // y component of translation
        PerDrawSrg::m_positionBuffer[11 + 16 * billboardIndex] // z component of translation
    );
    const float heightToWidthRatio = 1.0; // float(texDims.y) / float(texDims.x);
    const float3 vertexModelPosition = GetVertexModelPosition(vertexIndex, heightToWidthRatio);
    //const float3 movedVertexPosition = MoveUsingTime(vertexModelPosition,0.5);
    const float3 pushedVertexPosition = PerDrawSrg::PushByPerlinNoise(vertexModelPosition,translation);
    float4 vertexWorldPosition = PerDrawSrg::GetWorldPositionBufferNoRotation(pushedVertexPosition,billboardIndex);
    
    float3 noise_position = float3( translation.x,translation.y+0.5,PerDrawSrg::m_time*LoopLength*3);
    float noise = PerlinNoiseFbm(noise_position, 1/LoopLength, 2, 1);
    float3 rotatedVertexWorldPosition = PerDrawSrg::RotateAroundBladeCenter(vertexWorldPosition, 0.0f,billboardIndex);

    // 1. Compute angle between the camera and the billboard
    // 2. Rotate the billboard around the center of the blade such that it faces the camera
    // 3. Compute the world position of the vertex after rotation

    // 1 
    float3 cameraPos = ViewSrg::m_worldPosition;
    float3 cameraPos2 = float3(cameraPos.x,cameraPos.y,rotatedVertexWorldPosition.z);
    float3 forward = normalize(cameraPos2 - rotatedVertexWorldPosition);
    float3 right = cross(float3(0, 0, -1), forward); // Cross product of up and forward vectors
    float3 up = float3(0, 0, 1);

    bool isInfront = dot(forward,rotatedVertexWorldPosition) > 0;
    if (!isInfront)
    {
        right = -right;
    }
    right *= 0.2;
    // 2
    float3 center = float3(translation.x,translation.y,0);
    float3 rotatedVertexPosition = PerDrawSrg::RotateAroundZ(rotatedVertexWorldPosition,center,0);

    // 3
    const row_major float4x4 tm = {
        right.x, forward.x, up.x, rotatedVertexPosition.x,
        right.y, forward.y, up.y, rotatedVertexPosition.y,
        right.z, forward.z, up.z, rotatedVertexPosition.z,
                0,           0,    0,            1.0,
    };
    vertexWorldPosition = mul(tm, float4(vertexModelPosition, 1));

    

    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);

    //OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, float4(rotatedVertexWorldPosition,1));
    //const float4 vertexWorldPosition = PerDrawSrg::GetWorldPositionBuffer(movedVertexPosition,billboardIndex);
    //OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);

    //OUT.m_position = PerDrawSrg::GetBillboardClipCoordinates(vertexIndex,billboardIndex);
    // color based on distance from 0.0
    float distance = length(vertexModelPosition.xz - float2(0.0, TotalHeight*0.8 ))/TotalHeight;
    // clamp to 0.0 to 0.2
    distance = max(0.0, min(0.4, distance));
    // green color with saturation based on distance
    float3 green = float3(0, 1, 0);
    // change to hsv
    float3 hsv = RgbToHsv(green);
    // change saturation
    hsv.y -= distance;
    // change back to rgb
    float4 color = float4(HsvToRgb(hsv),1);
    OUT.m_color = color;
    //OUT.m_color = float4(distance, distance, distance, 1);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);

    
    return OUT;
};

struct PSOutput
{
    float4 m_color : SV_Target0;
};

struct AutoBrickVSOutput
{
    precise linear centroid float4 m_position : SV_Position;
    float3 m_normal: NORMAL;
    float4 m_tangent : TANGENT;
    float3 m_worldPosition : UV0;
    uint m_instanceId : SV_InstanceID;
};

ForwardPassOutput AutoBrick_ForwardPassPS(AutoBrickVSOutput IN)
{
    // uint billboardIndex = 0;
    // const row_major float4x4 m_modelToWorld2 = float4x4(
    //     PerDrawSrg::m_positionBuffer[0+16*billboardIndex], PerDrawSrg::m_positionBuffer[1+16*billboardIndex], PerDrawSrg::m_positionBuffer[2+16*billboardIndex], PerDrawSrg::m_positionBuffer[3+16*billboardIndex],
    //     PerDrawSrg::m_positionBuffer[4+16*billboardIndex], PerDrawSrg::m_positionBuffer[5+16*billboardIndex], PerDrawSrg::m_positionBuffer[6+16*billboardIndex], PerDrawSrg::m_positionBuffer[7+16*billboardIndex],
    //     PerDrawSrg::m_positionBuffer[8+16*billboardIndex], PerDrawSrg::m_positionBuffer[9+16*billboardIndex], PerDrawSrg::m_positionBuffer[10+16*billboardIndex], PerDrawSrg::m_positionBuffer[11+16*billboardIndex],
    //     PerDrawSrg::m_positionBuffer[12+16*billboardIndex], PerDrawSrg::m_positionBuffer[13+16*billboardIndex], PerDrawSrg::m_positionBuffer[14+16*billboardIndex], PerDrawSrg::m_positionBuffer[15+16*billboardIndex]
    // );
    // real4x4 objectToWorld = real4x4(m_modelToWorld2);
    // GetObjectToWorldMatrixInverseTranspose
    // real3x3 objectToWorldIT = real3x3(objectToWorld);

    float3 normalWS, tangentWS, bitangentWS;
    //ConstructTBN(real3(IN.m_normal), real4(IN.m_tangent), objectToWorld, objectToWorldIT, normalWS, tangentWS, bitangentWS);
    normalWS = float3(0,1,0);
    tangentWS = float3(1,0,0);
    bitangentWS = float3(0,0,1);


    float3x3 identityUvMatrix = 
        { 1,0,0,
          0,1,0,
          0,0,1 };
          
    float depthOffset = 0.0;
    

    float4 image_sample = float4(0,0.5,0,1);
    if (image_sample.a < 0.5)
    {
        discard;
    }
    float3 baseColor = image_sample.rgb;
    //float surfaceDepth = 0.5;
    float3 surfaceNormal = normalize(float3(0, 1, 0));
    // GetSurfaceShape(IN.m_uv, surfaceDepth, surfaceNormal);
    const float3 surfaceNormalWorld = TangentSpaceToWorld(surfaceNormal, normalWS, tangentWS, bitangentWS);
    
    // ------- Surface -------

    Surface surface;
    
    // Position, Normal, Roughness
    surface.position = IN.m_worldPosition.xyz;
    surface.normal = normalize(surfaceNormalWorld);
    surface.vertexNormal = surfaceNormal;
    surface.roughnessLinear = 1.0f;
    surface.CalculateRoughnessA();

    // Albedo, SpecularF0
    const float metallic = 0.0f;
    const float specularF0Factor = 0.0f;
    surface.SetAlbedoAndSpecularF0(baseColor, specularF0Factor, metallic);

    // Clear Coat
    surface.clearCoat.InitializeToZero();

    // ------- LightingData -------

    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(IN.m_position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    // (real3 positionWS, real3 normal, real roughnessLinear)
    lightingData.Init(ViewSrg::m_worldPosition.xyz, surface.normal, surface.roughnessLinear);

    // Shadow
    lightingData.diffuseAmbientOcclusion = 1.0f - 0.0f;

    // Diffuse and Specular response
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0f - lightingData.specularResponse;

    const float alpha = 1.0f;

    // ------- Lighting Calculation -------

    // Apply Decals
    ApplyDecals(lightingData.tileIterator, surface);

    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData, IN.m_position);

    // Apply Image Based Lighting (IBL)
    ApplyIblForward(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting();

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);

    // ------- Output -------
    // experiment
    float3 shadowmapUV = float3(0,0,0);
    float shadowmapDepth = PassSrg::m_directionalLightShadowmap.Sample(PerDrawSrg::LinearSampler, shadowmapUV).r;


    ForwardPassOutput OUT;

    OUT.m_diffuseColor = lightingOutput.m_diffuseColor;
    OUT.m_diffuseColor.w = -1; // Subsurface scattering is disabled
    //image_sample;//
    OUT.m_specularColor =  lightingOutput.m_specularColor;
    //OUT.m_specularColor =  float4(lightingData.diffuseLighting,1);
    //bool isLight = o_enableAreaLights;
    // if (isLight)
    // {
    //     OUT.m_specularColor = float4(0,1,0,1);
    // }else{
    //     OUT.m_specularColor =  float4(1,0,0,1);
    // }

   
    OUT.m_specularF0 = lightingOutput.m_specularF0;
    //OUT.m_specularF0 = image_sample;
    OUT.m_albedo = lightingOutput.m_albedo;
    OUT.m_normal = lightingOutput.m_normal;

    return OUT;
}




ForwardPassOutput MainPS(VSOutput IN)
{
    PSOutput OUT;
    // OUT.m_color = float4(1, 0, 0, 1);
    // return OUT;
    const float2 texCoord = IN.m_texCoord.xy;

    // struct AutoBrickVSOutput
    // {
    //     precise linear centroid float4 m_position : SV_Position;
    //     float3 m_normal: NORMAL;
    //     float4 m_tangent : TANGENT;
    //     float3 m_worldPosition : UV0;
    //     float2 m_uv : UV1;
    //     uint m_instanceId : SV_InstanceID;
    // };
    AutoBrickVSOutput autoBrickVsOutput;
    autoBrickVsOutput.m_position = IN.m_position;
    autoBrickVsOutput.m_normal = float3(0,1,0);
    autoBrickVsOutput.m_tangent = float4(1,0,0,1);
    autoBrickVsOutput.m_worldPosition = float3(0,0,0);
    autoBrickVsOutput.m_instanceId = 0;

    ForwardPassOutput  OUTFP = AutoBrick_ForwardPassPS(autoBrickVsOutput);
    return OUTFP;

//     float4 color = PerDrawSrg::m_inputTexture.Sample(PerDrawSrg::LinearSampler, texCoord).rgba;
//     color = float4(0, 1, 0, 1);

//     // color is based on distance from 0.0
//     float distance =  length(texCoord - float2(0.5, 0.5));
//     color = IN.m_color;

//    // color.a = 0.50;
//  //  color.r = 1.00;
//     if (color.a < 0.5) // Change this condition as per your requirement
//     {
//         discard;
//     }
    
//     OUT.m_color = color;
//     //OUT.m_color = float4(1, 1, 1, 1);
//     return OUT;

}; 
