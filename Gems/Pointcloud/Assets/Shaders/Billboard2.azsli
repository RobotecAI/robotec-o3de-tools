/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
#include <Atom/Features/ParallaxMapping.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "TileablePerlinNoise_A.azsli"
#include "kr_utils.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassOutput.azsli>
#include <Atom/Features/PBR/AlphaUtils.azsli>
#include <Atom/Features/PBR/LightingOptions.azsli>

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>

#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <Atom/Features/Pipeline/Forward/ForwardPassSrg.azsli>

#include <Atom/Features/PBR/Lighting/StandardLighting.azsli>
#include <Atom/Features/PBR/Lights/IblForward.azsli>
#include <Atom/Features/PBR/Decals.azsli>
#include <Atom/Features/ColorManagement/TransformColor.azsli>

static float TotalHeight = 2.0;
static float TotalWidth = 0.3;
static uint MaxSegments = 6;
static float SegmentHeight = TotalHeight / MaxSegments;
static float LoopLength = 30.0;
static uint TotalVertices = MaxSegments *6 -3;



float3 GetVertexModelPositionBezier(uint vertexId,float scale)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    uint vertexIndex = vertexId % 6;
    uint segmentIndex = vertexId / 6;
    bool isHead = vertexId >= TotalVertices-3;

    const float3 expansion[6] =
    {
        float3( TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0, 0),
    };
    const float3 head[3] =
    {
        float3(-TotalWidth, 0,  0),
        float3( 0, 0,  SegmentHeight*1),
        float3( TotalWidth, 0,  0),
    };
    float3 vertexModelPosition;
    if (isHead)
    {
        vertexModelPosition = head[vertexIndex];
    }else{
        vertexModelPosition = expansion[vertexIndex];
    }
    vertexModelPosition.z += segmentIndex * SegmentHeight;
    const float2 points[3] = {
        float2(0,50)/200,
        float2(100,50)/200,
        float2(200,0)/200
    };

    vertexModelPosition.x *= scale;
    vertexModelPosition.z *= scale;

    vertexModelPosition.x *= getPointAt2d(vertexModelPosition.z/TotalHeight,points[0],points[1],points[2]).y;
   // vertexModelPosition.y = yVal;
    return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
}



float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1),      
    };
    uint vertexIndex = vertexId % 6;
    return texcoord[vertexIndex];
}

ShaderResourceGroup PerObjectSrg : SRG_PerObject
{
    Buffer<float>  m_positionBuffer;
    Buffer<float> m_objectToWorldMatrixInverseTranspose;
    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.

    float m_totalHeight;
    float m_totalWidth;
    uint  m_maxSegments;
    float m_loopLength;
    float2 
    
    float m_windStrength;
    float m_windRotation;
    float m_greenHue;
    float m_greenSaturation;
    float m_distanceScale;
    float m_normalRotation;

    float3 RotateAroundZ(float3 position, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
        float3 p = position;
        float3 rotated;
        rotated.x = p.x * c - p.y * s;
        rotated.y = p.x * s + p.y * c;
        rotated.z = p.z;
        return float3(rotated);
    }

    void RotateAroundZ2(inout float3 position,inout float3 normal,float angle){
        position = RotateAroundZ(position,angle);
        normal = RotateAroundZ(normal,angle);
    }

    float3 GetBillboardPosition(uint billboardIndex)
    {
        return float3(
            m_positionBuffer[3 + 16 * billboardIndex], // x component of translation
            m_positionBuffer[7 + 16 * billboardIndex], // y component of translation
            m_positionBuffer[11 + 16 * billboardIndex] // z component of translation
        );
    }

    // float PerlinNoiseFbm(float3 input, float frequency, int octaves, float persistence) {
    void PushByPerlinNoise(inout float3 position,inout float3 normal, uint billboardIndex, float windStrength,float scale){

        float2 points[3] = {
            float2(0,0),
            float2(40,170),
            float2(100,120)
        };

        float2 pointsWind[3] = {
            float2(0,0),
            float2(40,60),
            float2(200,20)
        };

        const float scaled_z = position.z / (TotalHeight * scale);
        float2 pointsLerp[3] = {
            float2(0,0),
            float2(0,0),
            float2(0,0)
        };
        for (int i = 1; i < 3; i++)
        {
            pointsLerp[i] = lerp(points[i],pointsWind[i],windStrength)/200 * scale;
        }

        const float2 pushed_point = getPointAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
        position.yz = pushed_point.xy;
        normal.yz = getNormalAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
    }
}

// ShaderResourceGroup PerDrawSrg : SRG_PerObject
ShaderResourceGroup PerDrawSrg : SRG_PerDraw
{ 
    float m_time;
}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
    float3 m_worldPosition : UV0;
    float4 m_color : COLOR;
    float3 m_normal : NORMAL;
};

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(TotalVertices);
    const uint billboardIndex = uint(IN.m_vertexID) / uint(TotalVertices);
    // random value based on billboardId (0-1)
    const float scale = randomFloat(billboardIndex)/2 + 0.8;

    float3 translation = PerDrawSrg::GetBillboardPosition(billboardIndex);
    float3 vertexModelPosition = GetVertexModelPositionBezier(vertexIndex,scale);
    float x_distance = vertexModelPosition.x;
    float3 normal = float3(0,0,1);

    // generate wind noise
    float3 wind_direction = normalize(float3(2,1,0.1));
    float3 noise_position = float3( translation.x,translation.y,0);
    noise_position += wind_direction * PerDrawSrg::m_time*LoopLength*1;
    float windStrength = PerlinNoiseFbm(noise_position, 1.2/LoopLength, 2, 1)+1;
    float3 noise_position_rotation = float3( noise_position.x,noise_position.y,2);
    float windRotation = PerlinNoiseFbm(noise_position_rotation, 0.4/LoopLength, 2, 2);

    PerDrawSrg::PushByPerlinNoise(vertexModelPosition,normal,billboardIndex,windStrength,scale);
    PerDrawSrg::RotateAroundZ2(vertexModelPosition, normal,windRotation*2*3.14159*1);
    

    float4 vertexWorldPosition = float4(vertexModelPosition + translation, 1.0);
    

    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    OUT.m_normal = normalize(normal);//float3(1,0,0);
    OUT.m_worldPosition = vertexWorldPosition.xyz;

    // color based on distance from 0.0
    float distance = length(vertexModelPosition.xz - float2(0.0, TotalHeight*0.8 ))/TotalHeight;
    // clamp to 0.0 to 0.2
    distance = max(0.0, min(0.4, distance));
    // green color with saturation based on distance
    float3 green = float3(0.2*scale, 0.7*scale, 0);
    // change to hsv
    float3 hsv = RgbToHsv(green);
    // change saturation
    hsv.y -= distance;
    // change back to rgb
    float4 color = float4(HsvToRgb(hsv),1);
    OUT.m_color = color;
    //OUT.m_color = float4(0.3,0.7,0,1);
    //OUT.m_color = float4(distance, distance, distance, 1);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);

    
    return OUT;
};


ForwardPassOutput MainPS(VSOutput IN, bool isFrontFace : SV_IsFrontFace)
{

    
    float3 baseColor = IN.m_color.rgb;
    float3 surfaceNormal = IN.m_normal;
    if (!isFrontFace)
    {
        surfaceNormal = -surfaceNormal;
    }
    // ------- Surface -------

    Surface surface;
    
    // Position, Normal, Roughness
    surface.position = IN.m_worldPosition.xyz;
    
    float3 surface_normal = PerDrawSrg::RotateAroundZ(IN.m_normal,-(IN.m_texCoord.x-0.5)*3);
    surface.normal = normalize(surface_normal);
    surface.vertexNormal = surfaceNormal;
    surface.roughnessLinear = 0.9f;
    surface.CalculateRoughnessA();

    // Albedo, SpecularF0
    const float metallic = 0.0f;
    const float specularF0Factor = 0.1f;
    surface.SetAlbedoAndSpecularF0(baseColor, specularF0Factor, metallic);

    // Clear Coat
    surface.clearCoat.InitializeToZero();

    // ------- LightingData -------

    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(IN.m_position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    // (real3 positionWS, real3 normal, real roughnessLinear)
    lightingData.Init(ViewSrg::m_worldPosition.xyz, surface.normal, surface.roughnessLinear);

    // Shadow
    lightingData.diffuseAmbientOcclusion = 0.3f;

    // Diffuse and Specular response
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0f - lightingData.specularResponse;

    const float alpha = 1.0f;

    // ------- Lighting Calculation -------

    // Apply Decals
    ApplyDecals(lightingData.tileIterator, surface);

    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData, IN.m_position);

    // Apply Image Based Lighting (IBL)
    ApplyIblForward(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting();

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);

    // ------- Output -------
    ForwardPassOutput OUT;
    OUT.m_diffuseColor = lightingOutput.m_diffuseColor;
    OUT.m_diffuseColor.w = -1; // Subsurface scattering is disabled
    OUT.m_specularColor =  lightingOutput.m_specularColor;
    OUT.m_specularF0 = lightingOutput.m_specularF0;
    OUT.m_albedo = lightingOutput.m_albedo;
    OUT.m_normal = lightingOutput.m_normal;
    return OUT;
}; 
