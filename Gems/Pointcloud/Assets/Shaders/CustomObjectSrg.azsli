/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#pragma once
#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "TileablePerlinNoise_A.azsli"
#include "kr_utils.azsli"

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>



ShaderResourceGroup ObjectSrg : SRG_PerObject
{

    // DEFAULT STUFF
    uint m_objectId;

    //! Returns the matrix for transforming points from Object Space to World Space.
    float4x4 GetWorldMatrix()
    {
        return SceneSrg::GetObjectToWorldMatrix(m_objectId);
    }

    //! Returns the inverse-transpose of the world matrix.
    //! Commonly used to transform normals while supporting non-uniform scale.
    float3x3 GetWorldMatrixInverseTranspose()
    {
        return SceneSrg::GetObjectToWorldInverseTransposeMatrix(m_objectId);
    }

    float4x4 GetWorldMatrixPrev()
    {
        return SceneSrg::GetObjectToWorldMatrixPrev(m_objectId);
    }

    ReflectionProbeData m_reflectionProbeData;
    TextureCube m_reflectionProbeCubeMap;
    // DEFAULT STUFF

    //Buffer<float>  m_f_positionBuffer;
    //Texture2D<float4> m_t2_inputTexture; // A texture generated by a RenderJoy pipeline.

    uint m_u_gridWidth;
    uint m_u_gridLength;
    float m_f_cellSize;
    float m_f_placementNoiseScale;

    float m_f_totalHeight;
    float m_f_totalWidth;
    uint  m_u_maxSegments;



    float SegmentHeight(){
        return m_f_totalHeight / m_u_maxSegments;
    }

    uint m_u_vertexCountPerMesh(){
        return 6 * m_u_maxSegments-3;
    }

    float m_f_loopLength; 
    float2 m_f2_leafWidthCurvePoint1;
    float2 m_f2_leafWidthCurvePoint2;

    float2 m_f2_leafDefaultShapePoint2;
    float2 m_f2_leafDefaultShapePoint3;

    float2 m_f2_leafFullWindShapePoint2;
    float2 m_f2_leafFullWindShapePoint3;

    // color params
    float3 m_f3_baseColor; // Diffuse color, Default float3(1,1,1)
    float m_f_metallic; // Metallic, Default 0.0
    float m_f_roughness; // Roughness, Default 0.9
    float m_f_alpha;    // Alpha, Default 1.0
    float m_f_diffuseAmbientOcclusion; // Ambient Occlusion, Default 0.3
    float m_f_specularF0Factor;     // Specular F0 Factor, Default 0.1  
    float m_f_specularOcclusion;   // Specular Occlusion, Default 0.5

    // wind params
    float3 m_f3_windDirection;
    float m_f_windSpeed;
    float m_f_windStrength;
    float m_f_windScale;
    float m_f_windStrengthFrequencyScale;
    float m_f_windRotationStrengthFrequencyScale;
    float m_u_windOctaves;
    float m_f_windPersistence;

    float3 GetVertexModelPositionBezier(uint vertexId,float scale)
    {
        // If you use your right hand
        // these trinagles are facing in Y+ direction, 
        // 3 2---0  
        // | \\  |
        // |  \\ |
        // 5---4 1
        uint vertexIndex = vertexId % 6;
        uint segmentIndex = vertexId / 6;
        bool isHead = vertexId >= m_u_vertexCountPerMesh()-3;

        const float3 expansion[6] =
        {
            float3( m_f_totalWidth, 0,  SegmentHeight()),
            float3( m_f_totalWidth, 0, 0),
            float3(-m_f_totalWidth, 0,  SegmentHeight()),
            float3(-m_f_totalWidth, 0,  SegmentHeight()),
            float3( m_f_totalWidth, 0, 0),
            float3(-m_f_totalWidth, 0, 0),
        };
        const float3 head[3] =
        {
            float3(-m_f_totalWidth, 0,  0),
            float3( 0, 0,  SegmentHeight()*1),
            float3( m_f_totalWidth, 0,  0),
        };
        float3 vertexModelPosition;
        if (isHead)
        {
            vertexModelPosition = head[vertexIndex];
        }else{
            vertexModelPosition = expansion[vertexIndex];
        }
        vertexModelPosition.z += segmentIndex * SegmentHeight();
        const float2 points[3] = {
            m_f2_leafWidthCurvePoint1,
            m_f2_leafWidthCurvePoint2,
            float2(1,0)
        };

        vertexModelPosition.x *= scale;
        vertexModelPosition.z *= scale;

        vertexModelPosition.x *= getPointAt2d(vertexModelPosition.z/m_f_totalHeight,points[0],points[1],points[2]).y;
    // vertexModelPosition.y = yVal;
        return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
    }


    float3 RotateAroundZ(float3 position, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
        float3 p = position;
        float3 rotated;
        rotated.x = p.x * c - p.y * s;
        rotated.y = p.x * s + p.y * c;
        rotated.z = p.z;
        return float3(rotated);
    }

    void RotateAroundZ2(inout float3 position,inout float3 normal,float angle){
        position = RotateAroundZ(position,angle);
        normal = RotateAroundZ(normal,angle);
    }

      
    float3 GetBillboardPosition(uint billboardIndex)
    {
        //return float3(1,1,1);
        uint x = billboardIndex % m_u_gridWidth;
        uint y = billboardIndex / m_u_gridWidth;
        // Calculate base position based on grid index and cell size
        float3 position;
        position.x = (x + 0.5) * m_f_cellSize - (m_u_gridWidth * m_f_cellSize) / 2.0f; 
        position.z = 0;
        position.y = (y + 0.5) * m_f_cellSize - (m_u_gridLength * m_f_cellSize) / 2.0f; 

        // add some random offset to the position
        float2 noise =  randomNormalPair(billboardIndex*134);
        position.xy += noise * m_f_cellSize * m_f_placementNoiseScale;
        return position; 
    }

    


    // float PerlinNoiseFbm(float3 input, float frequency, int octaves, float persistence) {
    void PushByPerlinNoise(inout float3 position,inout float3 normal, uint billboardIndex, float windStrength,float scale){

        float2 points[3] = {
            float2(0,0),
            m_f2_leafDefaultShapePoint2,
            m_f2_leafDefaultShapePoint3
        };

        float2 pointsWind[3] = {
            float2(0,0),
            m_f2_leafFullWindShapePoint2,
            m_f2_leafFullWindShapePoint3
        };

        const float scaled_z = position.z / (m_f_totalHeight * scale);
        float2 pointsLerp[3] = {
            float2(0,0),
            float2(0,0),
            float2(0,0)
        };
        for (int i = 1; i < 3; i++)
        {
            pointsLerp[i] = lerp(points[i],pointsWind[i],windStrength) * scale;
        }

        const float2 pushed_point = getPointAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
        position.yz = pushed_point.xy;
        normal.yz = getNormalAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
    }

    void GenerateWindNoise(inout float3 vertexModelPosition, inout float3 normal, float3 translation, uint billboardIndex, float time) {
        // Calculate the noise position
        float3 noisePosition = float3(translation.x, translation.y, 0);
        noisePosition +=  time * m_f3_windDirection * ObjectSrg::m_f_loopLength * m_f_windSpeed;

        // Calculate the wind strength
        //float windStrength = PerlinNoiseFbm(noisePosition, m_f_windStrengthFrequencyScale / ObjectSrg::m_f_loopLength, m_u_windOctaves, m_f_windPersistence) + 1;
        float windStrength = PerlinNoiseFbm(noisePosition, m_f_windStrengthFrequencyScale / ObjectSrg::m_f_loopLength, 2, m_f_windPersistence) + 1;


        // Apply the wind noise to the vertex position
        ObjectSrg::PushByPerlinNoise(vertexModelPosition, normal, billboardIndex, windStrength, m_f_windScale);

        // Calculate the wind rotation
        float3 noisePositionRotation = float3(noisePosition.x, noisePosition.y, 2);
        float windRotation = PerlinNoiseFbm(noisePositionRotation, m_f_windRotationStrengthFrequencyScale / ObjectSrg::m_f_loopLength, 2, m_f_windPersistence+1);

        // Apply the wind rotation to the vertex position
        ObjectSrg::RotateAroundZ2(vertexModelPosition, normal,windRotation *2 * 3.14159);
    }
}
