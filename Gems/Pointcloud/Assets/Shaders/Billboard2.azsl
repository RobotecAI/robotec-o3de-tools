/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
#include <Atom/Features/ParallaxMapping.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "TileablePerlinNoise_A.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassOutput.azsli>
#include <Atom/Features/PBR/AlphaUtils.azsli>
#include <Atom/Features/PBR/LightingOptions.azsli>

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>

#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <Atom/Features/Pipeline/Forward/ForwardPassSrg.azsli>

#include <Atom/Features/PBR/Lighting/StandardLighting.azsli>
#include <Atom/Features/PBR/Lights/IblForward.azsli>
#include <Atom/Features/PBR/Decals.azsli>
#include <Atom/Features/ColorManagement/TransformColor.azsli>

static float TotalHeight = 2.0;
static float TotalWidth = 0.3;
static uint MaxSegments = 6;
static float SegmentHeight = TotalHeight / MaxSegments;
static float LoopLength = 30.0;
static uint TotalVertices = MaxSegments *6 -3;


float GetScaledTime(float time)
{
    return time / LoopLength;
}

//https://jsfiddle.net/0nk4m36j/10/ 
float2 getPointAt2d(float t, float2 p1, float2 pc, float2 p2) {
    float x = (1 - t) * (1 - t) * p1.x + 2 * (1 - t) * t * pc.x + t * t * p2.x;
    float y = (1 - t) * (1 - t) * p1.y + 2 * (1 - t) * t * pc.y + t * t * p2.y;
    return float2(x,y);
}

float2 getDerivativeAt2d(float t, float2 p1, float2 pc, float2 p2) {
    float2 d1 = float2(2 * (pc.x - p1.x), 2 * (pc.y - p1.y));
    float2 d2 = float2(2 * (p2.x - pc.x), 2 * (p2.y - pc.y));

    float x = (1 - t) * d1.x + t * d2.x;
    float y = (1 - t) * d1.y + t * d2.y;

    return float2(x,y);
}

float2 getNormalAt2d(float t, float2 p1, float2 pc, float2 p2) {
    float2 d = getDerivativeAt2d(t, p1, pc, p2);
    float q = sqrt(d.x * d.x + d.y * d.y);

    float x = -d.y / q;
    float y = d.x / q;
    
    return float2(x,y);
}

float3 GetVertexModelPosition(uint vertexId)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    uint vertexIndex = vertexId % 6;
    uint segmentIndex = vertexId / 6;
    bool isHead = vertexId >= TotalVertices-3;

    const float3 expansion[6] =
    {
        float3( TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0, 0),
    };
    const float3 head[3] =
    {
        float3(-TotalWidth, 0,  0),
        float3( 0.5*TotalWidth, 0,  SegmentHeight*1),
        float3( TotalWidth, 0,  0),
    };
    float3 vertexModelPosition;
    if (isHead)
    {
        vertexModelPosition = head[vertexIndex];
    }else{
        vertexModelPosition = expansion[vertexIndex];
    }
    vertexModelPosition.z += segmentIndex * SegmentHeight;
   // vertexModelPosition.y = yVal;
    return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
}

float3 GetVertexModelPositionBezier(uint vertexId)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    uint vertexIndex = vertexId % 6;
    uint segmentIndex = vertexId / 6;
    bool isHead = vertexId >= TotalVertices-3;

    const float3 expansion[6] =
    {
        float3( TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3(-TotalWidth, 0,  SegmentHeight),
        float3( TotalWidth, 0, 0),
        float3(-TotalWidth, 0, 0),
    };
    const float3 head[3] =
    {
        float3(-TotalWidth, 0,  0),
        float3( 0, 0,  SegmentHeight*1),
        float3( TotalWidth, 0,  0),
    };
    float3 vertexModelPosition;
    if (isHead)
    {
        vertexModelPosition = head[vertexIndex];
    }else{
        vertexModelPosition = expansion[vertexIndex];
    }
    vertexModelPosition.z += segmentIndex * SegmentHeight;
    const float2 points[3] = {
        float2(0,50)/200,
        float2(100,50)/200,
        float2(200,0)/200
    };

    vertexModelPosition.x *= getPointAt2d(vertexModelPosition.z/TotalHeight,points[0],points[1],points[2]).y;
   // vertexModelPosition.y = yVal;
    return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
}



float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1),      
    };
    uint vertexIndex = vertexId % 6;
    return texcoord[vertexIndex];
}

// ShaderResourceGroup PerObjectSrg : SRG_PerDraw
// {
//     float m_time;
// }

// ShaderResourceGroup PerDrawSrg : SRG_PerObject
ShaderResourceGroup PerDrawSrg : SRG_PerDraw
{ 

    Buffer<float>  m_positionBuffer;
    Buffer<float> m_objectToWorldMatrixInverseTranspose;
    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.
    float m_time;
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Mirror;
        AddressV = Mirror;
        AddressW = Mirror;
    };

    float3 RotateAroundZ(float3 position, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
        float3 p = position;
        float3 rotated;
        rotated.x = p.x * c - p.y * s;
        rotated.y = p.x * s + p.y * c;
        rotated.z = p.z;
        return float3(rotated);
    }

    void RotateAroundZ2(inout float3 position,inout float3 normal,float angle){
        position = RotateAroundZ(position,angle);
        normal = RotateAroundZ(normal,angle);
    }

    float3 GetBillboardPosition(uint billboardIndex)
    {
        return float3(
            m_positionBuffer[3 + 16 * billboardIndex], // x component of translation
            m_positionBuffer[7 + 16 * billboardIndex], // y component of translation
            m_positionBuffer[11 + 16 * billboardIndex] // z component of translation
        );
    }

    // float PerlinNoiseFbm(float3 input, float frequency, int octaves, float persistence) {
    void PushByPerlinNoise(inout float3 position,inout float3 normal, uint billboardIndex, float windStrength){

        float2 points[3] = {
            float2(0,0),
            float2(40,170),
            float2(100,140)
        };

        float2 pointsWind[3] = {
            float2(0,0),
            float2(40,90),
            float2(200,60)
        };


        const float scaled_z = position.z / TotalHeight;
        //const float y_push = PerDrawSrg::getPointAt(scaled_z*noise,0,.1,10.0);

        // lerp points based on noise between points and pointsWind
        float2 pointsLerp[3] = {
            float2(0,0),
            float2(0,0),
            float2(0,0)
        };
        for (int i = 1; i < 3; i++)
        {
            pointsLerp[i] = lerp(points[i],pointsWind[i],windStrength)/200;
        }

        const float2 pushed_point = getPointAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
        // Modify the y value of the input position based on the y value of P
        position.yz = pushed_point.xy; //* noise*5;
        
        // compute normal
        //normal.x = -getDerivativeAt(scaled_z*noise,0,.1,10.0);
        normal.yz = getNormalAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);

        //move normal and position based on noise 
        // position.y *= noise*3;
        

    }
}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
    
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
    float3 m_worldPosition : UV0;
    float4 m_color : COLOR;
    float3 m_normal : NORMAL;

};

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(TotalVertices);
    const uint billboardIndex = uint(IN.m_vertexID) / uint(TotalVertices);
    float3 translation = PerDrawSrg::GetBillboardPosition(billboardIndex);
    float3 vertexModelPosition = GetVertexModelPositionBezier(vertexIndex);
    float3 normal = float3(0,0,1);

    // generate wind noise
    float3 wind_direction = normalize(float3(2,1,0.1));
    float3 noise_position = float3( translation.x,translation.y,0);
    noise_position += wind_direction * PerDrawSrg::m_time*LoopLength*5;
    float windStrength = PerlinNoiseFbm(noise_position, 0.8/LoopLength, 2, 2);
    float3 noise_position_rotation = float3( noise_position.x,noise_position.y,2);
    float windRotation = PerlinNoiseFbm(noise_position_rotation, 0.8/LoopLength, 2, 2);

    PerDrawSrg::PushByPerlinNoise(vertexModelPosition,normal,billboardIndex,windStrength);
    PerDrawSrg::RotateAroundZ2(vertexModelPosition, normal,windRotation*2*3.14159);
    

    float4 vertexWorldPosition = float4(vertexModelPosition + translation, 1.0);
    

    bool frontVisible = dot(normal,ViewSrg::m_worldPosition - vertexWorldPosition.xyz) > 0;
    if (!frontVisible)
    {
        normal = -normal;
    }


    // // 1. Compute angle between the camera and the billboard
    // // 2. Rotate the billboard around the center of the blade such that it faces the camera
    // // 3. Compute the world position of the vertex after rotation

    // // 1 

    // // 2
    // float3 center = float3(translation.x,translation.y,0);
    // float3 rotatedVertexPosition = PerDrawSrg::RotateAroundZ(vertexWorldPosition,center,0);

    // // 3
    // const row_major float4x4 tm = {
    //     right.x, forward.x, up.x, rotatedVertexPosition.x,
    //     right.y, forward.y, up.y, rotatedVertexPosition.y,
    //     right.z, forward.z, up.z, rotatedVertexPosition.z,
    //             0,           0,    0,            1.0,
    // };
    // vertexWorldPosition = mul(tm, float4(vertexModelPosition, 1));

    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    OUT.m_normal = normalize(normal);//float3(1,0,0);
    OUT.m_worldPosition = vertexWorldPosition.xyz;

    // color based on distance from 0.0
    float distance = length(vertexModelPosition.xz - float2(0.0, TotalHeight*0.8 ))/TotalHeight;
    // clamp to 0.0 to 0.2
    distance = max(0.0, min(0.4, distance));
    // green color with saturation based on distance
    float3 green = float3(0, 1, 0);
    // change to hsv
    float3 hsv = RgbToHsv(green);
    // change saturation
    hsv.y -= distance;
    // change back to rgb
    float4 color = float4(HsvToRgb(hsv),1);
    OUT.m_color = color;
    //OUT.m_color = float4(0.3,0.7,0,1);
    //OUT.m_color = float4(distance, distance, distance, 1);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);

    
    return OUT;
};


ForwardPassOutput MainPS(VSOutput IN)
{

        
    float3 baseColor = IN.m_color.rgb;
    float3 surfaceNormal = IN.m_normal;
    const float3 surfaceNormalWorld = IN.m_normal;
    
    // ------- Surface -------

    Surface surface;
    
    // Position, Normal, Roughness
    surface.position = IN.m_worldPosition.xyz;
    surface.normal = normalize(surfaceNormalWorld);
    surface.vertexNormal = surfaceNormal;
    surface.roughnessLinear = 0.9f;
    surface.CalculateRoughnessA();

    // Albedo, SpecularF0
    const float metallic = 0.0f;
    const float specularF0Factor = 0.1f;
    surface.SetAlbedoAndSpecularF0(baseColor, specularF0Factor, metallic);

    // Clear Coat
    surface.clearCoat.InitializeToZero();

    // ------- LightingData -------

    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(IN.m_position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    // (real3 positionWS, real3 normal, real roughnessLinear)
    lightingData.Init(ViewSrg::m_worldPosition.xyz, surface.normal, surface.roughnessLinear);

    // Shadow
    lightingData.diffuseAmbientOcclusion = 0.3f;

    // Diffuse and Specular response
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0f - lightingData.specularResponse;

    const float alpha = 1.0f;

    // ------- Lighting Calculation -------

    // Apply Decals
    ApplyDecals(lightingData.tileIterator, surface);

    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData, IN.m_position);

    // Apply Image Based Lighting (IBL)
    ApplyIblForward(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting();

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);

    // ------- Output -------
    ForwardPassOutput OUT;
    OUT.m_diffuseColor = lightingOutput.m_diffuseColor;
    OUT.m_diffuseColor.w = -1; // Subsurface scattering is disabled
    OUT.m_specularColor =  lightingOutput.m_specularColor;
    OUT.m_specularF0 = lightingOutput.m_specularF0;
    OUT.m_albedo = lightingOutput.m_albedo;
    OUT.m_normal = lightingOutput.m_normal;
    return OUT;
}; 
