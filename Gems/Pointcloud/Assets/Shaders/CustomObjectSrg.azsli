/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#pragma once
#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "TileablePerlinNoise_A.azsli"
#include "kr_utils.azsli"

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>



ShaderResourceGroup ObjectSrg : SRG_PerObject
{

    // DEFAULT STUFF
    uint m_objectId;

    //! Returns the matrix for transforming points from Object Space to World Space.
    float4x4 GetWorldMatrix()
    {
        return SceneSrg::GetObjectToWorldMatrix(m_objectId);
    }

    //! Returns the inverse-transpose of the world matrix.
    //! Commonly used to transform normals while supporting non-uniform scale.
    float3x3 GetWorldMatrixInverseTranspose()
    {
        return SceneSrg::GetObjectToWorldInverseTransposeMatrix(m_objectId);
    }

    float4x4 GetWorldMatrixPrev()
    {
        return SceneSrg::GetObjectToWorldMatrixPrev(m_objectId);
    }

    ReflectionProbeData m_reflectionProbeData;
    TextureCube m_reflectionProbeCubeMap;
    // DEFAULT STUFF

    Buffer<float>  m_f_positionBuffer;
    Texture2D<float4> m_t2_inputTexture; // A texture generated by a RenderJoy pipeline.

    float m_f_totalHeight;
    float m_f_totalWidth;
    uint  m_u_maxSegments;

    float SegmentHeight(){
        return m_f_totalHeight / m_u_maxSegments;
    }

    uint m_u_vertexCountPerMesh;
    float m_f_loopLength; 



    float3 GetVertexModelPositionBezier(uint vertexId,float scale)
    {
        // If you use your right hand
        // these trinagles are facing in Y+ direction, 
        // 3 2---0  
        // | \\  |
        // |  \\ |
        // 5---4 1
        uint vertexIndex = vertexId % 6;
        uint segmentIndex = vertexId / 6;
        bool isHead = vertexId >= m_u_vertexCountPerMesh-3;

        const float3 expansion[6] =
        {
            float3( m_f_totalWidth, 0,  SegmentHeight()),
            float3( m_f_totalWidth, 0, 0),
            float3(-m_f_totalWidth, 0,  SegmentHeight()),
            float3(-m_f_totalWidth, 0,  SegmentHeight()),
            float3( m_f_totalWidth, 0, 0),
            float3(-m_f_totalWidth, 0, 0),
        };
        const float3 head[3] =
        {
            float3(-m_f_totalWidth, 0,  0),
            float3( 0, 0,  SegmentHeight()*1),
            float3( m_f_totalWidth, 0,  0),
        };
        float3 vertexModelPosition;
        if (isHead)
        {
            vertexModelPosition = head[vertexIndex];
        }else{
            vertexModelPosition = expansion[vertexIndex];
        }
        vertexModelPosition.z += segmentIndex * SegmentHeight();
        const float2 points[3] = {
            float2(0,50)/200,
            float2(100,50)/200,
            float2(200,0)/200
        };

        vertexModelPosition.x *= scale;
        vertexModelPosition.z *= scale;

        vertexModelPosition.x *= getPointAt2d(vertexModelPosition.z/m_f_totalHeight,points[0],points[1],points[2]).y;
    // vertexModelPosition.y = yVal;
        return vertexModelPosition; //* PerDrawSrg::m_starParams.m_scale;
    }


    float3 RotateAroundZ(float3 position, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
        float3 p = position;
        float3 rotated;
        rotated.x = p.x * c - p.y * s;
        rotated.y = p.x * s + p.y * c;
        rotated.z = p.z;
        return float3(rotated);
    }

    void RotateAroundZ2(inout float3 position,inout float3 normal,float angle){
        position = RotateAroundZ(position,angle);
        normal = RotateAroundZ(normal,angle);
    }

    float3 GetBillboardPosition(uint billboardIndex)
    {
        return float3(
            m_f_positionBuffer[3 + 16 * billboardIndex], // x component of translation
            m_f_positionBuffer[7 + 16 * billboardIndex], // y component of translation
            m_f_positionBuffer[11 + 16 * billboardIndex] // z component of translation
        );
    }

    // float PerlinNoiseFbm(float3 input, float frequency, int octaves, float persistence) {
    void PushByPerlinNoise(inout float3 position,inout float3 normal, uint billboardIndex, float windStrength,float scale){

        float2 points[3] = {
            float2(0,0),
            float2(40,170),
            float2(100,120)
        };

        float2 pointsWind[3] = {
            float2(0,0),
            float2(40,60),
            float2(200,20)
        };

        const float scaled_z = position.z / (m_f_totalHeight * scale);
        float2 pointsLerp[3] = {
            float2(0,0),
            float2(0,0),
            float2(0,0)
        };
        for (int i = 1; i < 3; i++)
        {
            pointsLerp[i] = lerp(points[i],pointsWind[i],windStrength)/200 * scale;
        }

        const float2 pushed_point = getPointAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
        position.yz = pushed_point.xy;
        normal.yz = getNormalAt2d(scaled_z,pointsLerp[0],pointsLerp[1],pointsLerp[2]);
    }
}
